# 单例模式练习 2019-03-09
## 1、熟练掌握单例模式的常见写法
单例模式代码路径：com.venky.vip.day2

## 2、总结每种单例写法的优、缺点
- 饿汉式
在类加载的时候立即初始化，创建单例对象，绝对线程安全，在线程还没有出现之前就初始化了，不可能出现访问安全的问题。
优点：没有任何的锁，执行效率高，在用户体验上，比懒汉式更好。
缺点：类加载的时候就初始化，不管用不用都会占用内存，浪费内存。

- 懒汉式
懒汉式单例的特点，在外部类调用的时候才会加载，一定程度上节省了内存。
为了解决线程安全问题，不得不加锁，会导致一些性能问题。
    - 双重检查锁
    - 静态内部类（不需要使用锁，不过会被反射破坏单例）
优点：在调用的时候才会初始化对象，不会造成资源浪费
缺点：使用了锁，会造成一定的性能问题。

- 注册式
注册式单例又称为登记式单例，就是每一个实例都登记到某一个地方，使用唯一的标识获取实例。
注册式单例有两种写法
    - 容器缓存
    - 枚举登记
优点：没有涉及到锁，性能相对较高

## 3、思考破坏单例模式的方式有哪些？并且归纳总结
- 反射调用私有构造方法的形式
通过构造方法私有，是单例模式的形式，单反射可以调用所有私有的方法和变量，
会破坏类的封装性。可以通过一些手段，比如调用构造方法抛异常的形式，这些问题。
- 序列化存储后反序列化的形式
将对象序列化存储到磁盘，再次读取的时候反序列化为内存对象，破坏了对象的单例。

## 4、梳理内部类的执行逻辑，并画出时序图

类加载时机：JAVA虚拟机在有且仅有的5种场景下会对类进行初始化。
1. 遇到new、getstatic、setstatic或者invikestatic这4个字节码指令时，对应的java代码场景为：new一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。
3. 当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。
5. 当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是"有且仅有"，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。

 

我们再回头看下getInstance()方法，调用的是SingleTonHoler.INSTANCE，取的是SingleTonHoler里的INSTANCE对象，跟上面那个DCL(双重检查锁)方法不同的是，getInstance()方法并没有多次去new对象，故不管多少个线程去调用getInstance()方法，取的都是同一个INSTANCE对象，而不用去重新创建。
当getInstance()方法被调用时，SingleTonHoler才在SingleTon的运行时常量池里，把符号引用替换为直接引用，这时静态对象INSTANCE也真正被创建，然后再被getInstance()方法返回出去，这点同饿汉模式。那么INSTANCE在创建过程中又是如何保证线程安全的呢？在《深入理解JAVA虚拟机》中，有这么一句话:

> 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。

故而，可以看出INSTANCE在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。

那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数，所以，我们创建单例时，可以在静态内部类与DCL模式里自己斟酌。

内部类加载顺序：顺序是：父类静态属性 -> 父类静态代码块 -> 子类静态变量 ->子类静态代码块 -> 父类非静态变量 -> 父类非静态代码块 -> 父类构造函数 -> 子类非静态变量 -> 子类非静态代码块 ->子类构造函数
测试类：StaticInnerClassLoaderTime
[原文](https://blog.csdn.net/mnb65482/article/details/80458571) 